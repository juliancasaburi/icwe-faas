# Table 1: Summary of Migration Key Concepts (Chapter 4)

This table provides a comparative overview of key architectural and operational concepts discussed in Chapter 4, contrasting the typical approaches used in AWS Lambda (FaaS) with those required for a monolithic application deployed on Amazon EC2 (IaaS).

*   **Feature/Concept:** Identifies the specific technical area being discussed.
*   **AWS Lambda (FaaS) Approach:** Describes how the feature is inherently handled or typically implemented within the serverless Lambda environment.
*   **Monolithic EC2 (IaaS) Approach:** Outlines how the same feature is managed or needs to be explicitly configured within a traditional monolithic application running on EC2 instances.
*   **Key Migration Considerations:** Highlights the critical decisions, challenges, or changes required when transitioning from the FaaS approach to the IaaS approach for that specific feature.

| Feature/Concept           | AWS Lambda (FaaS) Approach                                   | Monolithic EC2 (IaaS) Approach                               | Key Migration Considerations                                                                                             |
| :------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------- |
| **Code Structure**        | Lambdalith (single function) or Single-Purpose Functions     | Consolidated application logic                               | Complexity depends on original FaaS structure; refactoring needed for maintainability.                                   |
| **State Management**      | Stateless; requires external storage (e.g., `DynamoDB`, `S3`) | Can be stateful (sticky sessions) or stateless (preferred for scaling) | Ensure statelessness for horizontal scaling or manage state appropriately (e.g., external cache/DB).                   |
| **Event-Driven Programming**          | Native integration with AWS services (e.g., `S3` triggers)     | Requires explicit implementation (e.g., message queues like `SQS`, polling) | Replicate event triggers using queues and consumers within the monolith or via external services.                       |
| **Rate Limiting**         | Usually handled via `Amazon API Gateway`                 | Implemented in-app (in-memory for single instance, external DB like `Redis` for scaled) or via reverse proxy/API Gateway | Choose implementation based on scaling needs and existing infrastructure (e.g., NGINX, `Amazon API Gateway`).                |
| **Database Transactions** | Distributed transactions often use SAGA pattern              | Standard ACID transactions within the monolith                 | Consolidate distributed transaction logic; SAGA complexity is removed.                                                   |
| **Authentication**        | Managed via cloud services (e.g., `Amazon Cognito`, Auth0)            | Options: Retain cloud service (SDK/API), implement SSO (e.g., Keycloak), manage within monolith (e.g., JWT) | Decide whether to keep external auth provider or bring auth logic into the monolith.                                   |
| **Logging & Monitoring**  | Automatic integration with `CloudWatch Logs`                 | Requires centralized logging setup (e.g., Logstash, CloudWatch Agent) & monitoring (e.g., `CloudWatch`, Prometheus) | Implement robust logging aggregation and monitoring across all instances.                                                |
| **AWS Service Permissions** | Granular `IAM` policies attached directly to functions         | `IAM` role attached to `EC2` instance(s) or managed credentials for off-AWS hosting | Define appropriate `IAM` roles for `EC2` instances based on required service access.                                       |
| **High Availability**     | Default (deployed across multiple `Availability Zones`)                       | Requires explicit configuration (multiple instances across Availability Zones, Load Balancer, Auto Scaling) | Design deployment strategy for High Availability if needed (`Auto Scaling Groups`, multiple `Availability Zones`); not always required, offering potential cost savings. |